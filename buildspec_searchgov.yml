
version: 0.2

env:
  parameter-store:
    APP_SERVER_ADDRESSES: "DEPLOY_SEARCHGOV_SERVER_ADDRESS"
    CRON_SERVER_ADDRESSES: "DEPLOY_CRON_SERVER_ADDRESSES"
    DEPLOYMENT_PATH: "DEPLOY_SEARCHGOV_DEPLOYMENT_PATH"
    RESQUE_SERVER_ADDRESSES: "DEPLOY_RESQUE_SERVER_ADDRESSES"
    RESQUE_WORKERS_COUNT: "DEPLOY_RESQUE_WORKERS_COUNT"
    SEARCHGOV_THREADS: "SEARCHGOV_THREADS"
    SEARCHGOV_WORKERS: "SEARCHGOV_WORKERS"
    SERVER_DEPLOYMENT_USER: "DEPLOY_SERVER_DEPLOYMENT_USER"
  exported-variables:
    - APP_SERVER_ADDRESSES
    - DEPLOYMENT_PATH
    - RESQUE_SERVER_ADDRESSES
    - SEARCHGOV_THREADS
    - SEARCHGOV_WORKERS
    - SERVER_DEPLOYMENT_USER

phases:
  install:
    runtime-versions:
      python: 3.x
    commands:
      - export PATH="$HOME/.rbenv/bin:$PATH"
      - eval "$(rbenv init -)"
      - git config --global --add safe.directory '*'
      - git config --global advice.detachedHead false

  pre_build:
    commands:
      - rm -rf ~/.bundle vendor/bundle || true
      # Write SSH key for server access
      - aws secretsmanager get-secret-value --secret-id "$SEARCH_SECRETSMANAGER_KEY_SECRET_NAME" --region "$SEARCH_AWS_REGION" --query 'SecretString' --output text > "$SEARCH_ENV_EC2_KEY"
      - chmod 600 "$SEARCH_ENV_EC2_KEY"

  build:
    commands:
      - echo "deploying searchgov app with capistrano"
      # Bundle setup (local vendor dir avoids global gems)
      - bundle config set --local silence_root_warning true
      - bundle config set --local path 'vendor/bundle'
      - bundle install --jobs=4 --retry=3

      # SSH agent + config for remote servers
      - eval "$(ssh-agent -s)"
      - ssh-add "$SEARCH_ENV_EC2_KEY"
      - mkdir -p ~/.ssh && chmod 700 ~/.ssh
      - |
        cat > ~/.ssh/config <<'CFG'
        Host *
          StrictHostKeyChecking no
          UserKnownHostsFile /dev/null
          ForwardAgent yes
        CFG
      - chmod 600 ~/.ssh/config

      # Ensure deployment path exists & is owned by the deploy user
      - bundle exec cap "$SEARCH_ENV" invoke "sudo mkdir -p \"$DEPLOYMENT_PATH\" && sudo chown -R $SERVER_DEPLOYMENT_USER:$SERVER_DEPLOYMENT_USER \"$DEPLOYMENT_PATH\""

      # --- SANITIZE/REPAIR REMOTE GIT MIRROR (fixes 'reference broken') ---
      - >
        bundle exec cap "$SEARCH_ENV" invoke
        "bash -lc 'set -euo pipefail
          REPO_PATH=\"${DEPLOYMENT_PATH%/}/repo\"
          mkdir -p \"$REPO_PATH\"
          cd \"$REPO_PATH\"

          # Create bare repo if missing
          if [ ! -d objects ]; then
            git init --bare
          fi

          # Must have origin set by prior deploy / :repo_url
          if ! git remote get-url origin >/dev/null 2>&1; then
            echo \"ERROR: remote mirror has no origin. Seed it by running a normal deploy once (sets :repo_url).\" >&2
            exit 1
          fi

          # Limit refspecs to heads & tags only (no PR refs)
          git config remote.origin.fetch \"+refs/heads/*:refs/heads/*\"
          git config --unset-all remote.origin.fetch '^\\+\\?refs/pull/.*' 2>/dev/null || true
          git config --add remote.origin.fetch \"+refs/tags/*:refs/tags/*\"

          # Purge any lingering PR refs from mirror
          find refs -type d -path \"*/pull\" -prune -exec rm -rf {} + 2>/dev/null || true
          find refs -type f -path \"refs/pull/*\" -print -delete 2>/dev/null || true
          sed -i \"/^.*refs\\/pull\\//d\" packed-refs 2>/dev/null || true

          # Fresh fetch with prune/force; if still bad, recreate mirror
          origin_url=$(git remote get-url origin)
          if ! git fetch origin --prune --tags --force; then
            cd \"${DEPLOYMENT_PATH}\"
            rm -rf repo
            git init --bare repo
            cd repo
            git remote add origin \"$origin_url\"
            git config remote.origin.fetch \"+refs/heads/*:refs/heads/*\"
            git config --add remote.origin.fetch \"+refs/tags/*:refs/tags/*\"
            git fetch origin --prune --tags --force
          fi

          git gc --prune=now --aggressive || true
          git fsck --no-dangling || true
        '"

      # Deploy + workers restart
      - bundle exec cap "$SEARCH_ENV" deploy
      - bundle exec cap "$SEARCH_ENV" resque:restart
      - bundle exec cap "$SEARCH_ENV" resque:scheduler:restart

artifacts:
  files:
    - '**/*'
