
version: 0.2
env:
  parameter-store:
    APP_SERVER_ADDRESSES: "DEPLOY_SEARCHGOV_SERVER_ADDRESS"
    CRON_SERVER_ADDRESSES: "DEPLOY_CRON_SERVER_ADDRESSES"
    DEPLOYMENT_PATH: "DEPLOY_SEARCHGOV_DEPLOYMENT_PATH"
    RESQUE_SERVER_ADDRESSES: "DEPLOY_RESQUE_SERVER_ADDRESSES"
    RESQUE_WORKERS_COUNT: "DEPLOY_RESQUE_WORKERS_COUNT"
    SEARCHGOV_THREADS: "SEARCHGOV_THREADS"
    SEARCHGOV_WORKERS: "SEARCHGOV_WORKERS"
    SERVER_DEPLOYMENT_USER: "DEPLOY_SERVER_DEPLOYMENT_USER"
    GITHUB_TOKEN: "DEPLOY_GITHUB_TOKEN"

exported-variables:
  - APP_SERVER_ADDRESSES
  - DEPLOYMENT_PATH
  - RESQUE_SERVER_ADDRESSES
  - SEARCHGOV_THREADS
  - SEARCHGOV_WORKERS
  - SERVER_DEPLOYMENT_USER
  - SSH_KEY_PATH

phases:
  install:
    runtime-versions:
      python: 3.x
    commands:
      - echo "Installing dependencies"

  pre_build:
    commands:
      - echo "=== Pre-build phase - Setting up environment ==="
      - export PATH="$HOME/.rbenv/bin:$PATH"
      - eval "$(rbenv init -)"
      - git config --global --add safe.directory '*'
      - pwd
      - ls -la
      - echo "=== Fixing Git ref corruption issues ==="
      - |
        if [ -d .git ]; then
          git gc --auto || true
          find .git/refs -type f -size 0 -delete 2>/dev/null || true
          if [ -f .git/refs/pull ]; then
            rm -f .git/refs/pull
          fi
          mkdir -p .git/refs/pull
          if [ -f .git/packed-refs ]; then
            cp .git/packed-refs .git/packed-refs.bak
            grep -v "^refs/pull/" .git/packed-refs.bak > .git/packed-refs || true
          fi
          git remote prune origin 2>/dev/null || echo "Remote prune skipped"
          git fetch --prune --tags origin '+refs/heads/*:refs/remotes/origin/*' '+refs/tags/*:refs/tags/*' 2>/dev/null || echo "Fetch skipped"
          if ! git fsck --full; then
            echo "Git integrity check failed - resetting repository..."
            rm -rf .git
            git init
            git remote add origin "$(git config --get remote.origin.url)"
            git fetch --depth=50 origin '+refs/heads/*:refs/remotes/origin/*'
            git checkout -B "$CODEBUILD_SOURCE_VERSION" "origin/$CODEBUILD_SOURCE_VERSION" || git checkout main
          fi
          echo "=== Git cleanup completed ==="
        else
          echo "WARNING: .git directory not found, skipping Git cleanup"
        fi

  build:
    commands:
      - echo "Repairing remote git mirror on targets"
      - |
        bundle exec cap "$SEARCH_ENV" invoke "bash -lc '
          set -euo pipefail
          DEPLOYMENT_PATH=${DEPLOYMENT_PATH:-/var/www/caps}
          SERVER_DEPLOYMENT_USER=${SERVER_DEPLOYMENT_USER:-ssm-user}
          REPO_PATH=\"$DEPLOYMENT_PATH/repo\"
          ORIGIN_URL=${CODEBUILD_SOURCE_REPO_URL:-$(git remote get-url origin 2>/dev/null || true)}
          [ -n \"$ORIGIN_URL\" ] || { echo \"No origin URL found\" >&2; exit 1; }

          sudo mkdir -p \"$DEPLOYMENT_PATH\"
          sudo chown -R \"$SERVER_DEPLOYMENT_USER:$SERVER_DEPLOYMENT_USER\" \"$DEPLOYMENT_PATH\"

          sudo -u \"$SERVER_DEPLOYMENT_USER\" bash -lc \"
            rm -rf \\\"$REPO_PATH\\\"
            mkdir -p \\\"$REPO_PATH\\\" && cd \\\"$REPO_PATH\\\"
            git init --bare
            git remote add origin \\\"$ORIGIN_URL\\\" || git remote set-url origin \\\"$ORIGIN_URL\\\"
            git config --unset-all remote.origin.fetch || true
            git config --add remote.origin.fetch '+refs/heads/*:refs/heads/*'
            git config --add remote.origin.fetch '+refs/tags/*:refs/tags/*'
            git fetch origin --prune --tags --force
            git fsck --no-dangling || true
          \"
        '"
      - echo "Deployingâ€¦"
      - bundle exec cap "$SEARCH_ENV" deploy

artifacts:
  files:
    - '**/*'
